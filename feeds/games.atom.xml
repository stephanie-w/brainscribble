<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Brain Scribble</title><link href="http://stephanie-w.github.io/" rel="alternate"></link><link href="http://stephanie-w.github.io/feeds/games.atom.xml" rel="self"></link><id>http://stephanie-w.github.io/</id><updated>2015-08-05T13:32:04+02:00</updated><entry><title>River Crossing Puzzle</title><link href="http://stephanie-w.github.io/crossing_river.html" rel="alternate"></link><updated>2015-08-05T13:32:04+02:00</updated><author><name>Stephanie W</name></author><id>tag:stephanie-w.github.io,2015-08-05:crossing_river.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;A river crossing puzzle is a type of transport puzzle in which the object is to carry items from one river bank to another. The difficulty of the puzzle may arise from restrictions on which or how many items can be transported at the same time, or from which or how many items may be safely left together. The setting may vary cosmetically, for example, by replacing the river by a bridge.&lt;/p&gt;
&lt;p&gt;The story:&lt;/p&gt;
&lt;p&gt;Once upon a time a farmer went to market and purchased a fox, a goose, and a bag of beans. On his way home, the farmer came to the bank of a river and rented a boat. But in crossing the river by boat, the farmer could carry only himself and a single one of his purchases - the fox, the goose, or the bag of beans.&lt;/p&gt;
&lt;p&gt;If left together, the fox would eat the goose, or the goose would eat the beans.&lt;/p&gt;
&lt;p&gt;The farmer's challenge was to carry himself and his purchases to the far bank of the river, leaving each purchase intact. How did he do it?&lt;/p&gt;
&lt;p&gt;Graph-Theoretic Analysis:&lt;/p&gt;
&lt;p&gt;The farmer (T for transporter) must transport a fox (F), a goose (G) and a bag of beans (B) from one side of a river to another using a boat which can only hold one item in addition to the farmer. For edibility reasons, the fox cannot be left alone with the goose, and the goose cannot be left alone with the beans.
So we can't have F and G together and G and B together.&lt;/p&gt;
&lt;p&gt;To draw the graph, let's have graph nodes listing items on one side of the river (T F G B), the edges will be the transport transition. The only possibles transitions are:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;* TFGB -&amp;gt; FB&lt;/span&gt;
&lt;span class="code-line"&gt;* TFB (the transporter comes back) -&amp;gt; B&lt;/span&gt;
&lt;span class="code-line"&gt;                                   -&amp;gt; F&lt;/span&gt;
&lt;span class="code-line"&gt;* B -&amp;gt; TGB&lt;/span&gt;
&lt;span class="code-line"&gt;* F -&amp;gt; TFG&lt;/span&gt;
&lt;span class="code-line"&gt;Then we always fing G alone, then TG, then nobody&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The departure river side graph is :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Departure River Side" src="/figure/river-crossing-departure-en.png" /&gt;&lt;/p&gt;
&lt;p&gt;The arrival river side graph is :
&lt;img alt="Arrival River Side" src="/figure/river-crossing-arrival-en.png" /&gt;&lt;/p&gt;
&lt;p&gt;These two graphs are inverted (right/left inversion from the other one), as there is only one graph of possible transitions, which is the same at the both river sides.
You can draw them simultaneously as two nodes at the same position on the graph must contains all items.&lt;/p&gt;
&lt;p&gt;There is two solutions to the problem, after leaving the goose alone on the arrival river side, the farmer can leave either the fox either the beans on the departure river side.&lt;/p&gt;</summary></entry><entry><title>Nim Games</title><link href="http://stephanie-w.github.io/nim-games.html" rel="alternate"></link><updated>2015-08-05T13:32:04+02:00</updated><author><name>Stephanie W</name></author><id>tag:stephanie-w.github.io,2015-08-05:nim-games.html</id><summary type="html">
&lt;hr/&gt;
&lt;!-- BEGIN_SUMMARY --&gt;
&lt;p&gt;Nim is a mathematical game of strategy in which two players take turns removing objects from distinct heaps. On each turn, a player must remove at least one object, and may remove any number of objects provided they all come from the same heap.&lt;/p&gt;
&lt;!-- END_SUMMARY --&gt;
&lt;p&gt;On a table, there is heaps of stones (or matches) from various sizes. Each player takes one or several stones in a single heap. The winner is the one who can empty the table.&lt;/p&gt;
&lt;h2 id="game-graph"&gt;Game Graph&lt;/h2&gt;
&lt;p&gt;The following graph represents a game with three heaps containing 1, 2 and 3 matches respectively.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/figure/nim-graph.png"/&gt;&lt;/p&gt;
&lt;p&gt;The graph shows the allowed and possible state after a given state.&lt;br/&gt;
For example from (1,1,2), the game rule allows the following states (1,1,1) or (1,2) or (1,1).&lt;/p&gt;
&lt;p&gt;The nodes in red compose the graph core. The graph core has the following property:&lt;/p&gt;
&lt;p&gt;(1) Every node out of a core has at least one successor, and among them a node of the core&lt;br/&gt;
(2) Any node from the core can't have as successor (if exist) a node from the core  &lt;/p&gt;
&lt;p&gt;A game state or position (or option) can be inside or outside the core. The loosing position(s) is inside the core (from first property).  &lt;/p&gt;
&lt;p&gt;The first position can be inside or outside the core.&lt;br/&gt;
Let's say it is outside, there is a winning strategy for the first player: step in the core (possible, cause of the first property), the second player will step out from the core (from the second property). Then the first player will step in the core once again, etc. If the first position was inside the core, then the second player could adopt the wining strategy of step in, step out the core alternalively.&lt;/p&gt;
&lt;p&gt;In the context of a finding a winning strategy, properties above can be rewritten as follow:&lt;/p&gt;
&lt;p&gt;(1') From a winning position, there is at least one move to a losing position (in the core)&lt;br/&gt;
(2') From a losing position, all moves lead to a winning position (outside the core)  &lt;/p&gt;
&lt;h2 id="determining-the-graph-core"&gt;Determining the graph core&lt;/h2&gt;
&lt;h3 id="the-xor-way"&gt;The XOR way&lt;/h3&gt;
&lt;p&gt;Let's try to find a way to compute a positive number for each node determining if the node is in the core or not.&lt;br/&gt;
Let's 0, the number assigned to the nodes of the core, so any number different from 0 is outside the core.  &lt;/p&gt;
&lt;p&gt;Let &lt;span class="math"&gt;\(x_1,\)&lt;/span&gt; ..., &lt;span class="math"&gt;\(x_n\)&lt;/span&gt; be the sizes of the heaps before a move, and &lt;span class="math"&gt;\(y_1\)&lt;/span&gt;, ..., &lt;span class="math"&gt;\(y_n\)&lt;/span&gt; the corresponding sizes after a move. 
We have to find an operation ? where, for a given position:&lt;br/&gt;
(1') if s = &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; ? &lt;span class="math"&gt;\(x_1 ? ... ? x_n = 0\)&lt;/span&gt; then all successor positions of this position verifing t = &lt;span class="math"&gt;\(y_0\)&lt;/span&gt; ? &lt;span class="math"&gt;\(y_1 ? ... ? y_n \ne 0\)&lt;/span&gt;&lt;br/&gt;
(1') s = if &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; ? &lt;span class="math"&gt;\(x_1 ? ... ? x_n \ne 0\)&lt;/span&gt; it exists a least a successor position of this position verifing t = &lt;span class="math"&gt;\(y_0\)&lt;/span&gt; ? &lt;span class="math"&gt;\(y_1 ? ... ? y_n = 0\)&lt;/span&gt;&lt;br/&gt;
with &lt;span class="math"&gt;\(x_i = y_i\)&lt;/span&gt; for all &lt;span class="math"&gt;\(i \ne k\)&lt;/span&gt;, and &lt;span class="math"&gt;\(x_k &amp;gt; y_k\)&lt;/span&gt; (any move from a position to an other can only change one of the &lt;span class="math"&gt;\(x_k\)&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;A such operation is the XOR (exclusive or) operation sybolized by &lt;span class="math"&gt;\(\oplus\)&lt;/span&gt;.&lt;br/&gt;
XOR is a logical bitwise operation, XOR is true only when an odd number of inputs is true.&lt;/p&gt;
&lt;p&gt;XOR Thruth Table:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;p&lt;/th&gt;
&lt;th&gt;q&lt;/th&gt;
&lt;th&gt;&lt;span class="math"&gt;\(p \oplus q\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;0 = FALSE&lt;/em&gt;&lt;br/&gt;
&lt;em&gt;1 = TRUE&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Proof:&lt;br/&gt;
(1') : If you change a single bits in a XOR of bits, you'll change the final result, ie. if &lt;span class="math"&gt;\(s = 0\)&lt;/span&gt; then &lt;span class="math"&gt;\(t \ne 0\)&lt;/span&gt; &lt;br/&gt;
(2') : From s, there is at least one way to get a sum t equal to 0 while respecting the rule of the game (ie. removing elements from a single heap): Let d be the position of the  leftmost one bit in s and k a heap where the dth bit is also one (it has to exist), then from position d (included) flip all the bit of &lt;span class="math"&gt;\(x_k\)&lt;/span&gt; correponding to the 1 in the sum s. The new sum s will be 0.&lt;/p&gt;
&lt;p&gt;Example : The sum is 01011 (the leftmost nonzero bit is at 2th bit). Using the first heap, flipping the 2nd, 4th and 5th bits:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    *&lt;/span&gt;
&lt;span class="code-line"&gt;  1 1 0 0 1         1 0 0 1 0 &lt;/span&gt;
&lt;span class="code-line"&gt;  0 1 1 1 1         0 1 1 1 1&lt;/span&gt;
&lt;span class="code-line"&gt;  1 0 0 1 1         1 0 0 1 1&lt;/span&gt;
&lt;span class="code-line"&gt;  0 0 0 1 1    =&amp;gt;   0 0 0 1 1&lt;/span&gt;
&lt;span class="code-line"&gt;  0 1 1 0 1         0 1 1 0 1&lt;/span&gt;
&lt;span class="code-line"&gt;  ---------         ---------&lt;/span&gt;
&lt;span class="code-line"&gt;  0 1 0 1 1         0 0 0 0 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We verify  &lt;span class="math"&gt;\(y_k\)&lt;/span&gt; &amp;lt; &lt;span class="math"&gt;\(x_k\)&lt;/span&gt; : all bits to the left of d are the same in &lt;span class="math"&gt;\(x_k\)&lt;/span&gt; and &lt;span class="math"&gt;\(y_k\)&lt;/span&gt;, bit d decreases from 1 to 0 (decreasing the value by 2d), and any change in the remaining bits will amount to at most &lt;span class="math"&gt;\(2^d-1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;By removing &lt;span class="math"&gt;\(x_k\)&lt;/span&gt; - &lt;span class="math"&gt;\(y_k\)&lt;/span&gt; objects from heap k, we get a let a loosing position for the other player.&lt;/p&gt;
&lt;p&gt;From our previous graph, applying XOR sum on heap sizes, we get: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/figure/nim-graph-2.png"/&gt;&lt;/p&gt;
&lt;p&gt;By computing these numbers to the graph, we define a Grundy function. The Grundy numbers are also called nimbers, as value of Nim heap.&lt;/p&gt;
&lt;p&gt;For any finite combinatorial game, there is only one way to decompose the (finite) set of positions into nimbers.&lt;/p&gt;
&lt;h3 id="the-hard-way"&gt;The hard way&lt;/h3&gt;
&lt;p&gt;An other way to find the core:&lt;/p&gt;
&lt;p&gt;A number can be assigned to each node so it follows the following property: The number of each node is the smallest number not in the successor numbers list.&lt;br/&gt;
For example A with number 3 has for successors B, C, D, F, then the successor numbers list is (0, 1, 2).&lt;/p&gt;
&lt;p&gt;This is an illustration of the Sprague-Grundy theorem which states that every impartial game is equivalent to a nim heap of a certain size.
Nimber addition (also known as nim-addition) can be used to calculate the size of a single heap equivalent to a collection of heaps. It is defined recursively by:&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha \oplus \beta = \operatorname{mex}(\{\,\alpha' \oplus \beta : \alpha' &amp;lt; \alpha\,\} \cup \{\, \alpha  \oplus \beta' : \beta' &amp;lt; \beta \,\})$$&lt;/div&gt;
&lt;p&gt;where for a set S of ordinals, mex(S) is defined to be the "minimum excluded ordinal", i.e. mex(S) is the smallest ordinal which is not an element of S.&lt;/p&gt;
&lt;p&gt;From our previous properties:&lt;br/&gt;
(1) Every node out of a core has at least one successor, and among them a node of the core&lt;br/&gt;
(2) Any node from the core can't have as successor (if exist) a node from the core  &lt;/p&gt;
&lt;p&gt;the relation with the Grundy number 0 and the core is a follow:&lt;br/&gt;
A number outside the core has a Grundy Number &amp;gt; 0, then 0 is in its successor number list (in respect of the first(1)).
A node with number 0 has as successors only successors with numbers not equal to 0, and then outside the core (in respect of (2)).&lt;/p&gt;
&lt;p&gt;For any finite combinatorial game, there is only one way to decompose the (finite) set of positions into two classes which satisfy (1) and (2).&lt;/p&gt;
&lt;p&gt;Note :&lt;br/&gt;
Example of a digital sum &lt;span class="math"&gt;\(7 \oplus 11\)&lt;/span&gt;: &lt;br/&gt;
&lt;span class="math"&gt;\(7 = 4 + 2 + 1 = 1.2^{2} + 1.2^{1} + 1.2^{0} = 111\)&lt;/span&gt;&lt;br/&gt;
&lt;span class="math"&gt;\(11 = 8 + 2 + 1 = 1.2^{3} + 0.2^{2} + 1.2^{1} + 1.2^{0} = 1011\)&lt;/span&gt;&lt;br/&gt;
Then we sum, the base 2 numbers, with 1 + 1 = 0  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    1 1 1&lt;/span&gt;
&lt;span class="code-line"&gt;+ 1 0 1 1&lt;/span&gt;
&lt;span class="code-line"&gt; --------&lt;/span&gt;
&lt;span class="code-line"&gt;  1 1 0 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(1100= 1.2^{3} + 1.2^{2} + 0.2^{1} + 0.2^{0} = 12\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(7 \oplus 11 = 12\)&lt;/span&gt;&lt;/p&gt;
&lt;!--
Sources:
https://en.wikipedia.org/wiki/Nim
https://en.wikipedia.org/wiki/Nimber
https://en.wikipedia.org/wiki/Exclusive_or
http://math.stackexchange.com/questions/416042/why-xor-operator-works
--&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry></feed>